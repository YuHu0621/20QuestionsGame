package gameutil;
/** 
* CommutativeExpressionReader.java
 **/

// IO
import java.io.*;

// XML
import javax.xml.parsers.DocumentBuilder; 
import javax.xml.parsers.DocumentBuilderFactory;  
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.*;
import database.BinaryTree;
import database.BinaryTreeNode;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult; 

/**
 * CommutativeExpressionWriter writes commutative arithmetic
 * expression trees to an xml format.
 * @author yu hu
 */
public class questionWritter
{   
   /** 
    * Writes question binary tree object to file.
    */
   public static boolean writeQuestion( BinaryTree<String> tree, String file )
   {
      return writeQuestion( tree, new File( file ) );
   }

  
   /** 
    * Writes BodyAndBarStructure object to file.
    */
   public static boolean writeQuestion( BinaryTree<String> tree, File file )
   {
   
      // obtain default parser
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      
      try 
      {
         // get DocumentBuilder
         DocumentBuilder builder = factory.newDocumentBuilder();
         
         Document document = builder.newDocument();
         
         // create root node
         Element root = createBinTreeElement( tree, document );
         	 
         // add root node to document
         document.appendChild( root );
	 
         // write document
         output( document, new StreamResult( file ) );
	 
         return true;
	 
      }
      catch ( ParserConfigurationException pce )
      {
         pce.printStackTrace();
      }
      return false;
   }

   /**
    * outputs document.
    **/
   private static void output( Document document, StreamResult result )
   {
      try 
      {
         // Use a Transformer for output
         TransformerFactory tFactory =
            TransformerFactory.newInstance();
         Transformer transformer = tFactory.newTransformer();

         DOMSource source = new DOMSource(document);
         transformer.transform(source, result);       
      } 
      catch (TransformerConfigurationException tce) 
      {
         // Error generated by the parser
         System.out.println ("\n** Transformer Factory error");
         System.out.println("   " + tce.getMessage() );

         // Use the contained exception, if any
         Throwable x = tce;
         if (tce.getException() != null)
            x = tce.getException();
         x.printStackTrace();
      } 
      catch (TransformerException te) 
      {
         // Error generated by the parser
         System.out.println ("\n** Transformation error");
         System.out.println("   " + te.getMessage() );

         // Use the contained exception, if any
         Throwable x = te;
         if (te.getException() != null)
            x = te.getException();
         x.printStackTrace();
      }
   }

   /**
    * creates expression element corresponding to tree.
    * @return Elements of all question and answers node.
    **/
   private static Element createBinTreeElement( BinaryTree<String> tree, Document document )
   {
     // create element with tag name expr
     return createExprNodeElement( tree.getRoot(), document );     
   }

   /**
    * creates element corresponding to expression node.
    * @return Element for node.
    **/
  private static Element createExprNodeElement( BinaryTreeNode<String> node, Document document )
  {
	  Element nodeElt;
      // base case
      if ( node.isLeaf() )
      {
    	  
        // create answer node
        nodeElt = document.createElement( "Answer" );

        // set value
        nodeElt.setAttribute( "text", node.getData() );
        
      
        
      } 
      // recursive case
      else
      {
    	  nodeElt = document.createElement( "Question" );
          nodeElt.setAttribute("text", node.getData());

        // create operator node
        Element opElt = document.createElement( "Question" );
        
        // set value
        opElt.setAttribute( "text", node.getData().toString() );


        // recursively 
        //leftChild
        if ( node.getLeftChild() != null )
          nodeElt.appendChild( createExprNodeElement( node.getLeftChild(), document ) );
        
        //rightChild
        if ( node.getRightChild() != null )
          nodeElt.appendChild( createExprNodeElement( node.getRightChild(), document ) );
        
        
      }
     return nodeElt;
   }

}
